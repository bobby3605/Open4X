#version 460
#extension GL_KHR_shader_subgroup_arithmetic : require
#extension GL_KHR_shader_subgroup_basic : require
#extension GL_KHR_shader_subgroup_ballot : require

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

struct InstanceData {
    uint objectIndex;
};

struct ObjectData {
    mat4 modelMatrix;
};

layout(set = 0, binding = 0) readonly buffer Instances { InstanceData instances[]; };

layout(push_constant) uniform constants {
    uint totalInstanceCount;
    float nearD;
    float farD;
    float ratio;
    float sphereFactorX;
    float sphereFactorY;
    float tang;
    vec3 X;
    vec3 Y;
    vec3 Z;
    vec3 camPos;
};

layout(std140, set = 0, binding = 1) readonly buffer Objects { ObjectData objects[]; };
layout(set = 0, binding = 2) buffer VisibleInstances { InstanceData visibleInstances[]; };

layout(set = 0, binding = 3) buffer PrefixSum { uint prefixSum[]; };
layout(set = 0, binding = 4) buffer LocalGroupTotals { uint localgroupTotals[]; };

// radar frustum culling implementation from
// http://www.lighthouse3d.com/tutorials/view-frustum-culling/radar-approach-implementation-ii/
bool sphereInFrustum(vec3 p, float radius) {

    float d;
    float az, ax, ay;
    bool result = true;

    vec3 v = p - camPos;

    az = dot(v, -Z);
    if (az > farD + radius || az < nearD - radius)
        return false;

    if (az > farD - radius || az < nearD + radius)
        result = true;

    ay = dot(v, Y);
    d = sphereFactorY * radius;
    az *= tang;
    if (ay > az + d || ay < -az - d)
        return false;

    if (ay > az - d || ay < -az + d)
        result = true;

    ax = dot(v, X);
    az *= ratio;
    d = sphereFactorX * radius;
    if (ax > az + d || ax < -az - d)
        return false;

    if (ax > az - d || ax < -az + d)
        result = true;

    return (result);
}

bool isVisible(uint index) {
    InstanceData instance = instances[index];
    mat4 modelMatrix = objects[instance.objectIndex].modelMatrix;
    mat4 modelMatrixT = transpose(modelMatrix);
    float xScale = length(modelMatrixT[0]);
    float yScale = length(modelMatrixT[1]);
    float zScale = length(modelMatrixT[2]);
    vec3 center = vec3(modelMatrix[3]);
    // might not work for radius because objects have different scaling
    // some models might have a much larger or smaller scale than others in order to be reasonably sized
    // this would make the radius too large or too small
    // need to convert scale from model space to world space?
    float radius = max(xScale, max(yScale, zScale)) * 0.5;
    return sphereInFrustum(center, radius);
}

#define SUBGROUP_SIZE 16
// NOTE:
// gl_WorkGroupSize is a compile-time constant, but gl_SubgroupSize isn't
// should be equal to gl_NumSubgroups
shared uint subgroupTotals[gl_WorkGroupSize.x / SUBGROUP_SIZE];
void main() {
    uint index = gl_GlobalInvocationID.x;
    InstanceData instance = instances[index];
    bool laneActive = index < totalInstanceCount && isVisible(index);
    uint inclusiveCount = subgroupBallotInclusiveBitCount(subgroupBallot(laneActive));

    // put the total from each subgroup in local group into shared memory
    // NOTE:
    // have to use SUBGROUP_SIZE here for intel because gl_SubgroupSize can vary on intel,
    // and 32 seems to always be passed, even if the actual size is 16
    // should probably file a bug report
    if (gl_SubgroupInvocationID == (SUBGROUP_SIZE - 1)) {
        subgroupTotals[gl_SubgroupID] = inclusiveCount;
    }

    barrier();

    if (gl_SubgroupID == 0) {
        if (gl_SubgroupInvocationID < gl_NumSubgroups) {
            subgroupTotals[gl_SubgroupInvocationID] = subgroupInclusiveAdd(subgroupTotals[gl_SubgroupInvocationID]);
        }
    }

    barrier();

    if (gl_LocalInvocationID.x == (gl_WorkGroupSize.x - 1)) {
        // NOTE;
        // the last local invocation is always in the last subgroup
        // the last subgroupID will be the total of the prefix sum of the subgroups in the workgroup
        localgroupTotals[gl_WorkGroupID.x] = subgroupTotals[gl_SubgroupID];
        atomicAdd(localgroupTotals[9], 1);
    }

    barrier();
    // FIXME:
    // use real barriers or a second dispatch instead of this
    while (localgroupTotals[9] < gl_NumWorkGroups.x) {
    }

    if (gl_SubgroupID == 0 && gl_WorkGroupID.x == 0) {
        if (gl_SubgroupInvocationID < gl_NumWorkGroups.x) {
            localgroupTotals[gl_SubgroupInvocationID] = subgroupInclusiveAdd(localgroupTotals[gl_SubgroupInvocationID]);
            atomicAdd(localgroupTotals[10], 1);
        }
    }

    barrier();
    while (localgroupTotals[10] < gl_NumWorkGroups.x) {
    }

    prefixSum[index] = (gl_WorkGroupID.x == 0 ? 0 : localgroupTotals[gl_WorkGroupID.x - 1]) +
                       (gl_SubgroupID == 0 ? 0 : subgroupTotals[gl_SubgroupID - 1]) + inclusiveCount;

    if (laneActive) {
        // NOTE:
        // - 1 to convert from inclusive to exclusive prefix sum
        visibleInstances[prefixSum[index] - 1] = instance;
    }
}
