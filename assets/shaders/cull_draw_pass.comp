#version 460

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

struct DrawCommand {
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int vertexOffset;
    uint firstInstance;
};

layout(set = 0, binding = 0) readonly buffer DrawCommands { DrawCommand drawCommands[]; };

layout(push_constant) uniform constants { uint indirectDrawCount; };

layout(set = 0, binding = 1) coherent buffer CulledDrawIndirectCount { uint culledDrawIndirectCount; };

layout(set = 0, binding = 2) buffer CulledDrawCommands { DrawCommand culledDrawCommands[]; };

/*
 * FIXME:
 * use compact here as well
layout(set = 1, binding = 0) buffer VisibilityBuffer { uint visibilityBuffer[]; };
layout(set = 1, binding = 1) buffer BlockCounts { uint blockCounts[]; };
*/

layout(set = 0, binding = 3) buffer PrefixSum { uint prefixSum[]; };

uint visibleInstances(uint di) {
    uint count;
    if (di != 0) {
        // prefixSum has an entry for each instance and is kept in order
        // prefixSum[drawCommands[di].instanceCount - 1] is the sum of all visible instances inclusive
        // prefixSum[drawCommands[di - 1].instanceCount - 1] is the sum of all visible instances of the previous draw, inclusive
        // their difference is the number of visible instances of drawCommands[di]
        DrawCommand currDraw = drawCommands[di];
        // FIXME:
        // prevDraw is not [di - 1], because draws can be in any order
        DrawCommand prevDraw = drawCommands[di - 1];
        return prefixSum[currDraw.firstInstance + currDraw.instanceCount - 1] -
               prefixSum[prevDraw.firstInstance + prevDraw.instanceCount - 1];
    } else {
        // NOTE:
        // This probably doesn't need to be offset by firstInstance
        return prefixSum[drawCommands[di].firstInstance + drawCommands[di].instanceCount - 1];
    }
}

void main() {
    uint drawIndex = gl_GlobalInvocationID.x;
    if (drawIndex >= indirectDrawCount) {
        return;
    }
    uint visibleInstanceCount = visibleInstances(drawIndex);
    if (visibleInstanceCount > 0) {
        DrawCommand drawCommand = drawCommands[drawIndex];
        // FIXME:
        // remove this check once prevDraw is fixed
        if (visibleInstanceCount > 100) {
            drawCommand.instanceCount = 0;
            drawCommand.firstIndex = visibleInstanceCount;
        } else {
            drawCommand.instanceCount = visibleInstanceCount;
        }

        // FIXME:
        // use compact instead of atomicAdd
        //        culledDrawCommands[atomicAdd(culledDrawIndirectCount, 1)] = drawCommand;
        culledDrawCommands[drawIndex] = drawCommand;
        atomicAdd(culledDrawIndirectCount, 1);
    }
}
