#version 460

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

struct DrawCommand {
   uint indexCount;
   uint instanceCount;
   uint firstIndex;
   int vertexOffset;
   uint firstInstance;
};

struct InstanceIndicesData {
    uint objectIndex;
};

struct objectData {
    mat4 modelMatrix;
};

layout(set = 0, binding = 0) readonly buffer DrawCommands {
    DrawCommand draws[];
} drawCommands;

layout(set = 0, binding = 1) readonly buffer InstanceIndices {
    InstanceIndicesData data[];
} instanceIndices;

layout(set = 0, binding = 2) writeonly buffer CulledDrawCommands {
    DrawCommand culledDraws[];
} culledDrawCommands;

layout(set = 0, binding = 3) writeonly buffer CulledInstanceIndices {
    InstanceIndicesData data[];
} culledInstanceIndices;

layout( push_constant ) uniform constants {
    uint drawIndirectCount;
};

layout(set = 0, binding = 4) buffer IndirectDrawCount {
    uint culledDrawIndirectCount;
};

layout(std140, set = 0, binding = 5) readonly buffer Objects { objectData data[]; }
objects;



void main(){
    uint di = gl_GlobalInvocationID.x;
    if(di >= drawIndirectCount) {
        return;
    }

    DrawCommand drawCommand = drawCommands.draws[di];

    if(drawCommand.instanceCount > 0) {
        uint instanceOffset = 0;
        uint visibleInstanceCount = 0;
        for(uint i = 0; i < drawCommand.instanceCount; ++i) {
            uint objectIndex = instanceIndices.data[drawCommand.firstInstance+i].objectIndex;
            mat4 modelMatrix = objects.data[objectIndex].modelMatrix;
            bool visible = true;
            if(visible) {
                // put the object index into the culled instance indices
                culledInstanceIndices.data[drawCommand.firstInstance+i-instanceOffset].objectIndex = objectIndex;
                // update visibleInstanceCount
                ++visibleInstanceCount;
            } else {
                // if not visible, then increase the instanceOffset so that
                // culledInstanceIndices doesn't have any gaps
                ++instanceOffset;
            }
        }
        // add the draw command to the draw commands buffer if it has visible instances
        if(visibleInstanceCount > 0) {
            drawCommand.instanceCount = visibleInstanceCount;
            culledDrawCommands.culledDraws[atomicAdd(culledDrawIndirectCount, 1)] = drawCommand;
        }
    }
}
