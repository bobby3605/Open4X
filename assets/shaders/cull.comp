#version 460

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

struct DrawCommand {
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int vertexOffset;
    uint firstInstance;
};

struct InstanceIndicesData {
    uint objectIndex;
};

struct objectData {
    mat4 modelMatrix;
};

layout(set = 0, binding = 0) readonly buffer DrawCommands { DrawCommand draws[]; }
drawCommands;

layout(set = 0, binding = 1) readonly buffer InstanceIndices { InstanceIndicesData data[]; }
instanceIndices;

layout(set = 0, binding = 2) writeonly buffer CulledDrawCommands { DrawCommand culledDraws[]; }
culledDrawCommands;

layout(set = 0, binding = 3) writeonly buffer CulledInstanceIndices { InstanceIndicesData data[]; }
culledInstanceIndices;

layout(push_constant) uniform constants {
    uint drawIndirectCount;
    float nearD;
    float farD;
    float ratio;
    float sphereFactorX;
    float sphereFactorY;
    float tang;
    vec3 X;
    vec3 Y;
    vec3 Z;
    vec3 camPos;
};

layout(set = 0, binding = 4) buffer IndirectDrawCount { uint culledDrawIndirectCount; };

layout(std140, set = 0, binding = 5) readonly buffer Objects { objectData data[]; }
objects;

// radar frustum culling implementation from
// http://www.lighthouse3d.com/tutorials/view-frustum-culling/radar-approach-implementation-ii/
bool sphereInFrustum(vec3 p, float radius) {

    float d;
    float az, ax, ay;
    bool result = true;

    vec3 v = p - camPos;

    az = dot(v, -Z);
    if (az > farD + radius || az < nearD - radius)
        return false;

    if (az > farD - radius || az < nearD + radius)
        result = true;

    ay = dot(v, Y);
    d = sphereFactorY * radius;
    az *= tang;
    if (ay > az + d || ay < -az - d)
        return false;

    if (ay > az - d || ay < -az + d)
        result = true;

    ax = dot(v, X);
    az *= ratio;
    d = sphereFactorX * radius;
    if (ax > az + d || ax < -az - d)
        return false;

    if (ax > az - d || ax < -az + d)
        result = true;

    return (result);
}

void main() {
    uint di = gl_GlobalInvocationID.x;
    if (di >= drawIndirectCount) {
        return;
    }

    DrawCommand drawCommand = drawCommands.draws[di];

    if (drawCommand.instanceCount > 0) {
        uint instanceOffset = 0;
        uint visibleInstanceCount = 0;
        for (uint i = 0; i < drawCommand.instanceCount; ++i) {
            uint objectIndex = instanceIndices.data[drawCommand.firstInstance + i].objectIndex;
            mat4 modelMatrix = objects.data[objectIndex].modelMatrix;
            mat4 modelMatrixT = transpose(modelMatrix);
            float xScale = length(modelMatrixT[0]);
            float yScale = length(modelMatrixT[1]);
            float zScale = length(modelMatrixT[2]);
            vec3 center = vec3(modelMatrix[3]);
            // might not work for radius because objects have different scaling
            // some models might have a much larger or smaller scale than others in order to be reasonably sized
            // this would make the radius too large or too small
            // need to convert scale from model space to world space?
            float radius = max(xScale, max(yScale, zScale)) * 0.5;
            if (sphereInFrustum(center, radius)) {
                // put the object index into the culled instance indices
                culledInstanceIndices.data[drawCommand.firstInstance + i - instanceOffset].objectIndex = objectIndex;
                // update visibleInstanceCount
                ++visibleInstanceCount;
            } else {
                // if not visible, then increase the instanceOffset so that
                // culledInstanceIndices doesn't have any gaps
                ++instanceOffset;
            }
        }
        // add the draw command to the draw commands buffer if it has visible instances
        if (visibleInstanceCount > 0) {
            drawCommand.instanceCount = visibleInstanceCount;
            culledDrawCommands.culledDraws[atomicAdd(culledDrawIndirectCount, 1)] = drawCommand;
        }
    }
}
